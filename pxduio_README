	pxduio - user space io using memory mapping.
    --------------------------------------------

	The current design for transfering in kernel data to userspace application (px-storage) is using an home-grown px-fuse.
This driver in a gist, creates a control device, which is watched by userspace application. User space application waits for
notification (through poll constructs) over the control device, and uses ioctl over the control device to read,write and transfer 
data. It does also support metadata operations over the ioctl interface for creation, deletion of virtual px volumes (end user pxd devices).
The whole IO transfer not only involves multiple ioctl calls, but also involves full data copy, along with multiple context switches between
kernel and userspace application for receiving new requests and completing them eventually.

It is possible to improve this kernel<->userspace interface and avoid not only so many syscalls and associated context switches,
but entire data copy totally. pxduio is one such implementation using constructs from linux generic userspace IO (uio) to create a memory window,
which when mapped to a userspace process, can do all of the above actions without context switches and actual data copy.

Dependencies:
-------------
	The pxduio kernel module is an extension to px-fuse, and is dependent on uio kernel module as well. 
lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$ lsmod | grep px
px                     69632  2
uio                    20480  3 px
lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$

There is a single misc device (pxdmm-control) that is created and registered with linux uio module.
A new bus type (pxdmm) is also created that shall map all instances of pxdmm-control. In the below logs,
a single instance of pxdmm-control device is created and the relevant mappings shown.

lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$ ls -al /dev/pxdmm-control
crw------- 1 root root 10, 37 Mar 28 14:51 /dev/pxdmm-control
lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$
lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$ ls -al /sys/devices/pxdmm/
total 0
drwxr-xr-x  4 root root    0 Mar 28 17:11 .
drwxr-xr-x 16 root root    0 Mar 28 09:42 ..
drwxr-xr-x  3 root root    0 Mar 28 14:51 misc
lrwxrwxrwx  1 root root    0 Mar 28 17:11 module -> ../../module/px
drwxr-xr-x  2 root root    0 Mar 28 17:11 power
-rw-r--r--  1 root root 4096 Mar 28 14:51 uevent
lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$ ls -al /sys/devices/pxdmm/misc/
total 0
drwxr-xr-x 3 root root 0 Mar 28 17:11 .
drwxr-xr-x 4 root root 0 Mar 28 17:11 ..
drwxr-xr-x 4 root root 0 Mar 28 14:51 pxdmm-control
lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$ ls -al /sys/devices/pxdmm/misc/pxdmm-control/
total 0
drwxr-xr-x 4 root root    0 Mar 28 17:11 .
drwxr-xr-x 3 root root    0 Mar 28 17:11 ..
-r--r--r-- 1 root root 4096 Mar 28 17:11 dev
lrwxrwxrwx 1 root root    0 Mar 28 17:11 device -> ../../../pxdmm
-rw-r--r-- 1 root root 4096 Mar 28 17:11 map
drwxr-xr-x 2 root root    0 Mar 28 17:11 power
lrwxrwxrwx 1 root root    0 Mar 28 14:51 subsystem -> ../../../../class/misc
-rw-r--r-- 1 root root 4096 Mar 28 14:51 uevent
drwxr-xr-x 4 root root    0 Mar 28 14:51 uio0
-rw-r--r-- 1 root root 4096 Mar 28 17:11 unmap

Proof of concept:
------------------
Linux generic UIO module, needs a real device to be exposed through uio. Usually a pci/pcie device gets registered with linux uio module to be exposed through
memory mapping. But in this case, similar to px-fuse implementation of /dev/pxd/pxd-control, a new misc device /dev/pxdmm-control is
created. This is mapped as the real device for linux uio module to expose outside. The usual logic for virtual px user volumes under /dev/pxd/pxd<uniq>
is created for each user volume. But all IOs from this user volume are remapped to the pxdmm-control device, which can be picked from userspace
through direct memory reference operations. The BIG gain is, zero context switches and zero DATA COPY for all traffic from/to kernel to/from userspace.

lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$ ls -al /dev/pxdmm-control
crw------- 1 root root 10, 37 Mar 28 14:51 /dev/pxdmm-control
lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$


lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$ ls -al /dev/uio0
crw------- 1 root root 244, 0 Mar 28 14:51 /dev/uio0
lns@pwxbuild:~/srcs/src/github.com/portworx/px-fuse$

The magic is in the memory window definition, and how the mapping is estabilished. 
A single memory window is registered for the device, that holds the following regions.

a) mailbox
b) cmd registers, a pre-allocated ring structure
c) response register, a pre-allocated ring structure
d) devices window, a listing of all virtual block devices managed by that control device
e) data buffers.

Mailbox: This is a small fixed memory region from offset zero, that defines key parameters that allow userspace application
to find correct offsets for the other regions. It defines maximum number of outstanding requests for exchange,
cmd region offset, response region offset and the data buffer offsets within this memory region.
It also holds indexes into the cmd and response ring structures. The rings by themselves are part of the cmd and response region.

Cmd region: This holds new IO requests from kernel to userspace. A common cmdresp structure (64 bytes each) provide all needed metadata
for received IOs on the user volumes. A key io_index is part of this structure, that specifies the data buffer offset, from where,
actual data for this IO is available. 

Response region: This is very similar to cmd region. It holds responses from userspace application back to kernel. The io_index is still
valid and is the key that shall enable the kernel to find other persistent information held within the kernel to complete the actual IO.

Both cmd and response regions are rings. A ring is a typical IO path datastructure, can also be seen as a circular buffer.
The head pointer is moved by writer (kernel thread for new IO, userspace for new responses). The tail is the owned by the consumer end of the 
stack (user space for new IO, kernel for completed responses). Each of these indexes into the ring after filling up the information
are communicated to the other side through the mailbox. 

Both the kernel and the userspace communicate through this shared mailbox memory region, and can independently exchange requests and responses
successfully.

It is pertinent to note that, the io_index assigned to the cmd/request by the kernel is released only after a response is received. The data buffer region
is reserved based on the io_index and actual data transfer both ways happens through that reserved data region within the data buffer window.
Ofcourse, since the reservation is fixed upfront, there exists a maximum IO for each request currently set at MAXDATASIZE (1MB).
Within the kernel, for each IO, the block device bio data pages are remapped to this data region, so the data is fetched and written to the final destination straight away.

Device window: This is a listing of all current px virtual block devices created and managed 
by the kernel driver.

Current PoC state:
1) A simple userspace application waits for new requests, pulls them out of the cmd ring, does a crc checksum on the mapped data,
and confirms that the checksum matches to the request, and completes the request by writing a response to the response ring.

2) The kernel side, all IOs to userspace, allocates an io_index, maps data buffers to a memory window based 
on the io_index, and fills up a cmd ring entry. A dedicated thread, watches for new responses from the response ring,
and pulls them out, finds the original IO and completes it, finally releasing the io_index and unmapping the memory region for data buffer.

Memory layout and various regions:
----------------------------------

+++++++++++++ ^
+           + |
+ Mailbox   + |
+           + |
+++++++++++++ |
+           + |
+ hole      + |
+++++++++++++ |
+           + |
+ cmd region+ |
+++++++++++++ This first CMDR_SIZE (8MB) region is reserved and holds
+ response  + metadata regions (mailbox, cmd and response regions and devices listing)
+ region    + |
+++++++++++++ |
+           + |
+  devices  + |
+++++++++++++ |
+           + |
+  hole     + V
+++++++++++++
+           +
+           +
+           +
+           +
+  data     +
+  buffers  +
+           +
+           +
+           +
+           +
+           +
+++++++++++++

Data structures:
-----------------
mailbox:
struct pxdmm_mbox {
        const uint64_t queueSize;
        const uint64_t cmdOffset;
        const uint64_t respOffset;
        const uint64_t devOffset;
        const uint64_t dataOffset;

        // device list window parameters
        unsigned long devChecksum;
#ifdef __KERNEL__
#define LOCK_DEVWINDOW(mbox)  ((mbox)->devVersion = 0)
#define UNLOCK_DEVWINDOW(mbox,v)  ((mbox)->devVersion = (v))
#endif
#define DEVWINDOW_LOCKED(mbox)  ((mbox)->devVersion == 0)
#define DEVWINDOW_VERSION(mbox)  ((mbox)->devVersion)
        unsigned long devVersion;
        unsigned long ndevices;

        uint64_t cmdHead __attribute__((aligned(64)));
        uint64_t cmdTail __attribute__((aligned(64)));
        uint64_t respHead __attribute__((aligned(64)));
        uint64_t respTail __attribute__((aligned(64)));
} __attribute__((aligned(64)));

Common command and response structure:
struct pxdmm_cmdresp {
        uint32_t minor;
        uint32_t cmd;
        uint32_t cmd_flags;
        int hasdata;
        unsigned long dev_id;

        loff_t offset;
        loff_t length;

        unsigned long checksum;
        uint32_t status;

        // below 2 fields should be passed as is.
        uint32_t io_index;
        uintptr_t dev; // the pxdmm_dev used for this xfer
} __attribute__((aligned(64)));


Data buffer offset:
static inline
loff_t pxdmm_dataoffset(uint32_t io_index) {
        return CMDR_SIZE + (io_index * MAXDATASIZE);
}

Constants of interest that defines the entire memory window:
#define NREQUESTS (256)
#define MAXDATASIZE (1<<20)
#define NMAXDEVICES (256)
#define CMDR_SIZE (8<<20)

In all for the above constants, a total of 8MB + 256MB (264MB) is needed for each control device.

Conclusion:
------------
This completes a proof of concept of a working version that can service IOs
from userspace through direct memory mapping and avoid multiple ioctl syscalls
and entire data copy. It should be possible to extend this by creating one
control device for each CPU, and enabling multi threaded userspace application
to communicate over the control device on each CPU and keep all IO traffic local
to a single CPU, improving cache coherency and performance further.
